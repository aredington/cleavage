(ns cleavage.git-repository
  (:use [clojure.java.io])
  (:require [clojure.string :as str]
	    [clojure.contrib.strint :as strint]
	    [cleavage.repository :as repo])
  (:import (org.eclipse.jgit.lib Repository RepositoryBuilder Constants)
	   (org.eclipse.jgit.revwalk RevCommit RevWalk)
	   (org.eclipse.jgit.treewalk.filter PathFilter TreeFilter AndTreeFilter)))

(defn target-dir
  [dir]
  (file dir))

(defn repository
  "a JGit Repository instance generated by reading dir"
  [dir]
  (.. (RepositoryBuilder.) (findGitDir (target-dir dir)) (build)))
(memoize repository)

(defn repository-resolve
  [repository revision]
  (.resolve repository revision))

(defn git-revisions
  "list all the revisions in a repository"
  [repository]
  (let [rw (RevWalk. repository)]
    (.markStart rw (.parseCommit rw (repository-resolve repository "HEAD")))
    (map #(.name %1) (seq rw))))
(memoize git-revisions)

(defn revision-sequences
  [revisions]
  "returns a map of commits to sequential integers for each revision.
the first revision is 1, second 2, etc.
expects that revisions are passed in reverse order, that is
the first revision should return the most recent revision"
  (zipmap (reverse revisions) (range)))
(memoize revision-sequences)

(defn git-files
  "returns lazyseq of all the files in targetdir"
  [dir]
  (map #(git-relative-path dir %) (filter
   #(re-find #"\.java$" (.getName %1))
   (file-seq (target-dir dir)))))

(defn git-relative-path
  [dir file]
  (str/replace (str/replace (.getPath file) dir "") #"^\/" ""))

(defn git-commits
  "all the commits which touched specific file"
  [repository file revsision]
  (let [rw (RevWalk. repository)
	revision-sequences (revision-sequences (git-revisions repository))]
    (.markStart rw (.parseCommit rw (repository-resolve repository revsision)))
    (.setTreeFilter rw (AndTreeFilter/create (PathFilter/create file) TreeFilter/ANY_DIFF))
    (map #(.name %) (seq rw))))

(defn git-revision-contents
  [repository file revision]
  (let [resolve-query (strint/<< "~{revision}:~{file}")
	versioned-object-id (repository-resolve repository resolve-query)]
    (if (nil? versioned-object-id)
      ""
      (slurp (.. repository (open versioned-object-id) openStream)))))

(deftype GitRepository [dirpath]
  repo/ScmRepository
  (revisions [repo] (git-revisions (repository dirpath)))
  (files [repo] (git-files dirpath))
  (relative-path [repo repo-file] (git-relative-path dirpath repo-file))
  (revision-number [repo revision] (get (revision-sequences (git-revisions (repository dirpath))) revision))
  (commits [repo repo-file revision] (git-commits (repository dirpath) repo-file revision))
  (revision-contents [repo repo-file revision] (git-revision-contents (repository dirpath) repo-file revision)))
